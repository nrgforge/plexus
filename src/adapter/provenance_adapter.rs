//! ProvenanceAdapter — routes provenance write operations through ingest (ADR-012)
//!
//! Maps creation/structural provenance operations to graph mutations via emission.
//! The enrichment loop handles tag-concept bridging (TagConceptBridger) for add_mark.
//!
//! Operations routed through this adapter:
//! - CreateChain: emits chain node
//! - AddMark: emits mark node + contains edge
//! - LinkMarks: emits links_to edge
//! - DeleteMark: emits removal (cascade handles edges)
//!
//! Operations remaining direct (not through adapter):
//! - update_mark, archive_chain: read-modify-write pattern
//! - delete_chain, unlink_marks: deferred per OQ10 (edge removal)

use crate::adapter::events::GraphEvent;
use crate::adapter::sink::{AdapterError, AdapterSink};
use crate::adapter::traits::{Adapter, AdapterInput};
use crate::adapter::types::{EdgeRemoval, Emission, OutboundEvent};
use crate::graph::{dimension, ContentType, Context, Edge, Node, NodeId, PropertyValue};
use async_trait::async_trait;

/// Input data for the ProvenanceAdapter.
///
/// Each variant maps to one provenance write operation.
/// IDs are pre-generated by the caller so they can be returned
/// to the user without inspecting the emission result.
#[derive(Debug, Clone)]
pub enum ProvenanceInput {
    /// Create a new provenance chain.
    CreateChain {
        /// Pre-generated chain node ID
        chain_id: String,
        name: String,
        description: Option<String>,
    },
    /// Add a mark to a chain.
    AddMark {
        /// Pre-generated mark node ID
        mark_id: String,
        chain_id: String,
        file: String,
        line: u32,
        annotation: String,
        column: Option<u32>,
        mark_type: Option<String>,
        tags: Option<Vec<String>>,
    },
    /// Create a links_to edge between two marks.
    LinkMarks {
        source_id: String,
        target_id: String,
    },
    /// Delete a mark (and cascade its edges).
    DeleteMark {
        mark_id: String,
    },
    /// Remove a links_to edge between two marks.
    UnlinkMarks {
        source_id: String,
        target_id: String,
    },
    /// Delete a chain and all its marks.
    /// mark_ids are pre-resolved by the caller (MCP boundary).
    DeleteChain {
        chain_id: String,
        mark_ids: Vec<String>,
    },
}

/// Adapter that routes provenance write operations through the ingest pipeline.
///
/// Boundary validation (chain exists, endpoints exist) is the caller's
/// responsibility. The adapter trusts pre-validated input and focuses
/// purely on graph mutations.
pub struct ProvenanceAdapter;

impl ProvenanceAdapter {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl Adapter for ProvenanceAdapter {
    fn id(&self) -> &str {
        "provenance"
    }

    fn input_kind(&self) -> &str {
        "provenance"
    }

    async fn process(
        &self,
        input: &AdapterInput,
        sink: &dyn AdapterSink,
    ) -> Result<(), AdapterError> {
        let prov_input = input
            .downcast_data::<ProvenanceInput>()
            .ok_or(AdapterError::InvalidInput)?;

        match prov_input {
            ProvenanceInput::CreateChain {
                chain_id,
                name,
                description,
            } => {
                let mut node = Node::new_in_dimension(
                    "chain",
                    ContentType::Provenance,
                    dimension::PROVENANCE,
                );
                node.id = NodeId::from(chain_id.as_str());
                node.properties
                    .insert("name".to_string(), PropertyValue::String(name.clone()));
                if let Some(desc) = description {
                    node.properties.insert(
                        "description".to_string(),
                        PropertyValue::String(desc.clone()),
                    );
                }
                node.properties.insert(
                    "status".to_string(),
                    PropertyValue::String("active".to_string()),
                );

                sink.emit(Emission::new().with_node(node)).await?;
            }

            ProvenanceInput::AddMark {
                mark_id,
                chain_id,
                file,
                line,
                annotation,
                column,
                mark_type,
                tags,
            } => {
                let mark_node_id = NodeId::from(mark_id.as_str());
                let chain_node_id = NodeId::from(chain_id.as_str());

                let mut mark_node = Node::new_in_dimension(
                    "mark",
                    ContentType::Provenance,
                    dimension::PROVENANCE,
                );
                mark_node.id = mark_node_id.clone();
                mark_node.properties.insert(
                    "chain_id".to_string(),
                    PropertyValue::String(chain_id.clone()),
                );
                mark_node
                    .properties
                    .insert("file".to_string(), PropertyValue::String(file.clone()));
                mark_node
                    .properties
                    .insert("line".to_string(), PropertyValue::Int(*line as i64));
                mark_node.properties.insert(
                    "annotation".to_string(),
                    PropertyValue::String(annotation.clone()),
                );
                if let Some(col) = column {
                    mark_node
                        .properties
                        .insert("column".to_string(), PropertyValue::Int(*col as i64));
                }
                if let Some(t) = mark_type {
                    mark_node
                        .properties
                        .insert("type".to_string(), PropertyValue::String(t.clone()));
                }
                if let Some(ref tag_list) = tags {
                    let tag_vals: Vec<PropertyValue> = tag_list
                        .iter()
                        .map(|s| PropertyValue::String(s.clone()))
                        .collect();
                    mark_node
                        .properties
                        .insert("tags".to_string(), PropertyValue::Array(tag_vals));
                }

                let contains_edge = Edge::new_in_dimension(
                    chain_node_id,
                    mark_node_id,
                    "contains",
                    dimension::PROVENANCE,
                );

                sink.emit(Emission::new().with_node(mark_node).with_edge(contains_edge))
                    .await?;
            }

            ProvenanceInput::LinkMarks {
                source_id,
                target_id,
            } => {
                let edge = Edge::new_in_dimension(
                    NodeId::from(source_id.as_str()),
                    NodeId::from(target_id.as_str()),
                    "links_to",
                    dimension::PROVENANCE,
                );

                sink.emit(Emission::new().with_edge(edge)).await?;
            }

            ProvenanceInput::DeleteMark { mark_id } => {
                sink.emit(Emission::new().with_removal(NodeId::from(mark_id.as_str())))
                    .await?;
            }

            ProvenanceInput::UnlinkMarks {
                source_id,
                target_id,
            } => {
                sink.emit(
                    Emission::new().with_edge_removal(EdgeRemoval::new(
                        NodeId::from(source_id.as_str()),
                        NodeId::from(target_id.as_str()),
                        "links_to",
                    )),
                )
                .await?;
            }

            ProvenanceInput::DeleteChain {
                chain_id,
                mark_ids,
            } => {
                let mut emission = Emission::new();
                // Remove all marks (cascade handles their edges)
                for mid in mark_ids {
                    emission = emission.with_removal(NodeId::from(mid.as_str()));
                }
                // Remove the chain node (cascade handles contains edges)
                emission = emission.with_removal(NodeId::from(chain_id.as_str()));
                sink.emit(emission).await?;
            }
        }

        Ok(())
    }

    fn transform_events(&self, events: &[GraphEvent], _context: &Context) -> Vec<OutboundEvent> {
        let mut outbound = Vec::new();
        for event in events {
            match event {
                GraphEvent::NodesAdded { node_ids, adapter_id, .. } if adapter_id == "provenance" => {
                    let ids: Vec<String> = node_ids.iter().map(|id| id.to_string()).collect();
                    if !ids.is_empty() {
                        outbound.push(OutboundEvent::new("provenance_updated", ids.join(", ")));
                    }
                }
                GraphEvent::EdgesAdded { edge_ids, adapter_id, .. } if adapter_id == "provenance" => {
                    if !edge_ids.is_empty() {
                        let ids: Vec<String> = edge_ids.iter().map(|id| id.to_string()).collect();
                        outbound.push(OutboundEvent::new("edges_added", ids.join(", ")));
                    }
                }
                GraphEvent::NodesRemoved { node_ids, adapter_id, .. } if adapter_id == "provenance" => {
                    let ids: Vec<String> = node_ids.iter().map(|id| id.to_string()).collect();
                    if !ids.is_empty() {
                        outbound.push(OutboundEvent::new("provenance_removed", ids.join(", ")));
                    }
                }
                GraphEvent::EdgesRemoved { edge_ids, adapter_id, .. } if adapter_id == "provenance" => {
                    if !edge_ids.is_empty() {
                        let ids: Vec<String> = edge_ids.iter().map(|id| id.to_string()).collect();
                        outbound.push(OutboundEvent::new("edges_removed", ids.join(", ")));
                    }
                }
                _ => {}
            }
        }
        outbound
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::adapter::engine_sink::EngineSink;
    use crate::adapter::provenance::FrameworkContext;
    use crate::graph::Context;
    use std::sync::{Arc, Mutex};

    fn make_sink() -> (EngineSink, Arc<Mutex<Context>>) {
        let ctx = Arc::new(Mutex::new(Context::new("test")));
        let fw = FrameworkContext {
            adapter_id: "provenance".to_string(),
            context_id: "test".to_string(),
            input_summary: None,
        };
        let sink = EngineSink::new(ctx.clone()).with_framework_context(fw);
        (sink, ctx)
    }

    // === CreateChain ===

    #[tokio::test]
    async fn create_chain_emits_chain_node() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::CreateChain {
                chain_id: "chain-1".to_string(),
                name: "reading-notes".to_string(),
                description: Some("Notes from reading".to_string()),
            },
            "test",
        );

        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();
        let chain = ctx
            .get_node(&NodeId::from("chain-1"))
            .expect("chain node should exist");
        assert_eq!(chain.node_type, "chain");
        assert_eq!(chain.content_type, ContentType::Provenance);
        assert_eq!(chain.dimension, dimension::PROVENANCE);

        assert_eq!(
            chain.properties.get("name"),
            Some(&PropertyValue::String("reading-notes".to_string()))
        );
        assert_eq!(
            chain.properties.get("description"),
            Some(&PropertyValue::String("Notes from reading".to_string()))
        );
        assert_eq!(
            chain.properties.get("status"),
            Some(&PropertyValue::String("active".to_string()))
        );
    }

    #[tokio::test]
    async fn create_chain_without_description() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::CreateChain {
                chain_id: "chain-2".to_string(),
                name: "quick-notes".to_string(),
                description: None,
            },
            "test",
        );

        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();
        let chain = ctx.get_node(&NodeId::from("chain-2")).unwrap();
        assert!(chain.properties.get("description").is_none());
    }

    // === AddMark ===

    #[tokio::test]
    async fn add_mark_emits_mark_node_and_contains_edge() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        // Pre-create the chain node so the contains edge validates
        {
            let mut ctx = ctx.lock().unwrap();
            let mut chain = Node::new_in_dimension(
                "chain",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            chain.id = NodeId::from("chain-1");
            ctx.add_node(chain);
        }

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::AddMark {
                mark_id: "mark-1".to_string(),
                chain_id: "chain-1".to_string(),
                file: "notes.md".to_string(),
                line: 42,
                annotation: "walking through Avignon".to_string(),
                column: Some(5),
                mark_type: Some("reference".to_string()),
                tags: Some(vec!["#travel".to_string(), "#avignon".to_string()]),
            },
            "test",
        );

        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();

        // Mark node
        let mark = ctx
            .get_node(&NodeId::from("mark-1"))
            .expect("mark node should exist");
        assert_eq!(mark.node_type, "mark");
        assert_eq!(mark.content_type, ContentType::Provenance);
        assert_eq!(mark.dimension, dimension::PROVENANCE);
        assert_eq!(
            mark.properties.get("file"),
            Some(&PropertyValue::String("notes.md".to_string()))
        );
        assert_eq!(
            mark.properties.get("line"),
            Some(&PropertyValue::Int(42))
        );
        assert_eq!(
            mark.properties.get("annotation"),
            Some(&PropertyValue::String("walking through Avignon".to_string()))
        );
        assert_eq!(
            mark.properties.get("column"),
            Some(&PropertyValue::Int(5))
        );
        assert_eq!(
            mark.properties.get("type"),
            Some(&PropertyValue::String("reference".to_string()))
        );
        assert_eq!(
            mark.properties.get("tags"),
            Some(&PropertyValue::Array(vec![
                PropertyValue::String("#travel".to_string()),
                PropertyValue::String("#avignon".to_string()),
            ]))
        );

        // Contains edge: chain → mark
        let contains: Vec<_> = ctx
            .edges()
            .filter(|e| {
                e.source == NodeId::from("chain-1")
                    && e.target == NodeId::from("mark-1")
                    && e.relationship == "contains"
            })
            .collect();
        assert_eq!(contains.len(), 1);
        assert_eq!(contains[0].source_dimension, dimension::PROVENANCE);
        assert_eq!(contains[0].target_dimension, dimension::PROVENANCE);
    }

    #[tokio::test]
    async fn add_mark_minimal_fields() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        // Pre-create chain
        {
            let mut ctx = ctx.lock().unwrap();
            let mut chain = Node::new_in_dimension(
                "chain",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            chain.id = NodeId::from("chain-1");
            ctx.add_node(chain);
        }

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::AddMark {
                mark_id: "mark-2".to_string(),
                chain_id: "chain-1".to_string(),
                file: "main.rs".to_string(),
                line: 10,
                annotation: "entry point".to_string(),
                column: None,
                mark_type: None,
                tags: None,
            },
            "test",
        );

        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();
        let mark = ctx.get_node(&NodeId::from("mark-2")).unwrap();
        assert!(mark.properties.get("column").is_none());
        assert!(mark.properties.get("type").is_none());
        assert!(mark.properties.get("tags").is_none());
    }

    // === LinkMarks ===

    #[tokio::test]
    async fn link_marks_emits_links_to_edge() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        // Pre-create both mark nodes
        {
            let mut ctx = ctx.lock().unwrap();
            let mut m1 = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            m1.id = NodeId::from("mark-1");
            ctx.add_node(m1);

            let mut m2 = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            m2.id = NodeId::from("mark-2");
            ctx.add_node(m2);
        }

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::LinkMarks {
                source_id: "mark-1".to_string(),
                target_id: "mark-2".to_string(),
            },
            "test",
        );

        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();
        let links: Vec<_> = ctx
            .edges()
            .filter(|e| {
                e.source == NodeId::from("mark-1")
                    && e.target == NodeId::from("mark-2")
                    && e.relationship == "links_to"
            })
            .collect();
        assert_eq!(links.len(), 1);
        assert_eq!(links[0].source_dimension, dimension::PROVENANCE);
    }

    #[tokio::test]
    async fn link_marks_missing_endpoint_rejects_edge() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        // Only create source, not target
        {
            let mut ctx = ctx.lock().unwrap();
            let mut m1 = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            m1.id = NodeId::from("mark-1");
            ctx.add_node(m1);
        }

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::LinkMarks {
                source_id: "mark-1".to_string(),
                target_id: "mark-nonexistent".to_string(),
            },
            "test",
        );

        // process() succeeds — rejection is in the EmitResult, not an error
        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();
        assert_eq!(ctx.edge_count(), 0);
    }

    // === DeleteMark ===

    #[tokio::test]
    async fn delete_mark_removes_node_and_cascades_edges() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        // Setup: chain + mark + contains edge + links_to edge
        {
            let mut ctx = ctx.lock().unwrap();
            let mut chain = Node::new_in_dimension(
                "chain",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            chain.id = NodeId::from("chain-1");
            ctx.add_node(chain);

            let mut mark = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            mark.id = NodeId::from("mark-1");
            ctx.add_node(mark);

            let mut other_mark = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            other_mark.id = NodeId::from("mark-2");
            ctx.add_node(other_mark);

            ctx.add_edge(Edge::new_in_dimension(
                NodeId::from("chain-1"),
                NodeId::from("mark-1"),
                "contains",
                dimension::PROVENANCE,
            ));
            ctx.add_edge(Edge::new_in_dimension(
                NodeId::from("mark-1"),
                NodeId::from("mark-2"),
                "links_to",
                dimension::PROVENANCE,
            ));
        }

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::DeleteMark {
                mark_id: "mark-1".to_string(),
            },
            "test",
        );

        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();
        assert!(ctx.get_node(&NodeId::from("mark-1")).is_none());
        // Both edges involving mark-1 should be cascaded
        assert_eq!(ctx.edge_count(), 0);
        // Chain and other mark remain
        assert!(ctx.get_node(&NodeId::from("chain-1")).is_some());
        assert!(ctx.get_node(&NodeId::from("mark-2")).is_some());
    }

    #[tokio::test]
    async fn delete_nonexistent_mark_is_noop() {
        let adapter = ProvenanceAdapter::new();
        let (sink, _ctx) = make_sink();

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::DeleteMark {
                mark_id: "no-such-mark".to_string(),
            },
            "test",
        );

        // Should succeed — removal of nonexistent is noop per emit_inner
        adapter.process(&input, &sink).await.unwrap();
    }

    // === UnlinkMarks ===

    #[tokio::test]
    async fn unlink_marks_removes_links_to_edge() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        // Pre-create marks and a links_to edge
        {
            let mut ctx = ctx.lock().unwrap();
            let mut m1 = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            m1.id = NodeId::from("mark-1");
            ctx.add_node(m1);

            let mut m2 = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            m2.id = NodeId::from("mark-2");
            ctx.add_node(m2);

            ctx.add_edge(Edge::new_in_dimension(
                NodeId::from("mark-1"),
                NodeId::from("mark-2"),
                "links_to",
                dimension::PROVENANCE,
            ));
        }

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::UnlinkMarks {
                source_id: "mark-1".to_string(),
                target_id: "mark-2".to_string(),
            },
            "test",
        );

        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();
        // Edge removed but both nodes remain
        assert_eq!(ctx.edge_count(), 0);
        assert!(ctx.get_node(&NodeId::from("mark-1")).is_some());
        assert!(ctx.get_node(&NodeId::from("mark-2")).is_some());
    }

    #[tokio::test]
    async fn unlink_nonexistent_edge_is_noop() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        // Pre-create marks but no links_to edge
        {
            let mut ctx = ctx.lock().unwrap();
            let mut m1 = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            m1.id = NodeId::from("mark-1");
            ctx.add_node(m1);

            let mut m2 = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            m2.id = NodeId::from("mark-2");
            ctx.add_node(m2);
        }

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::UnlinkMarks {
                source_id: "mark-1".to_string(),
                target_id: "mark-2".to_string(),
            },
            "test",
        );

        // Should succeed — removing nonexistent edge is noop
        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();
        assert_eq!(ctx.edge_count(), 0);
    }

    // === DeleteChain ===

    #[tokio::test]
    async fn delete_chain_removes_chain_and_marks() {
        let adapter = ProvenanceAdapter::new();
        let (sink, ctx) = make_sink();

        // Setup: chain + 2 marks + contains edges + a links_to edge between marks
        {
            let mut ctx = ctx.lock().unwrap();
            let mut chain = Node::new_in_dimension(
                "chain",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            chain.id = NodeId::from("chain-1");
            ctx.add_node(chain);

            let mut m1 = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            m1.id = NodeId::from("mark-1");
            ctx.add_node(m1);

            let mut m2 = Node::new_in_dimension(
                "mark",
                ContentType::Provenance,
                dimension::PROVENANCE,
            );
            m2.id = NodeId::from("mark-2");
            ctx.add_node(m2);

            ctx.add_edge(Edge::new_in_dimension(
                NodeId::from("chain-1"),
                NodeId::from("mark-1"),
                "contains",
                dimension::PROVENANCE,
            ));
            ctx.add_edge(Edge::new_in_dimension(
                NodeId::from("chain-1"),
                NodeId::from("mark-2"),
                "contains",
                dimension::PROVENANCE,
            ));
            ctx.add_edge(Edge::new_in_dimension(
                NodeId::from("mark-1"),
                NodeId::from("mark-2"),
                "links_to",
                dimension::PROVENANCE,
            ));
        }

        let input = AdapterInput::new(
            "provenance",
            ProvenanceInput::DeleteChain {
                chain_id: "chain-1".to_string(),
                mark_ids: vec!["mark-1".to_string(), "mark-2".to_string()],
            },
            "test",
        );

        adapter.process(&input, &sink).await.unwrap();

        let ctx = ctx.lock().unwrap();
        assert!(ctx.get_node(&NodeId::from("chain-1")).is_none());
        assert!(ctx.get_node(&NodeId::from("mark-1")).is_none());
        assert!(ctx.get_node(&NodeId::from("mark-2")).is_none());
        assert_eq!(ctx.edge_count(), 0);
    }

    // === Invalid input ===

    #[tokio::test]
    async fn wrong_input_type_returns_invalid_input() {
        let adapter = ProvenanceAdapter::new();
        let (sink, _ctx) = make_sink();

        let input = AdapterInput::new(
            "provenance",
            "not a ProvenanceInput".to_string(),
            "test",
        );

        let result = adapter.process(&input, &sink).await;
        assert!(matches!(result, Err(AdapterError::InvalidInput)));
    }
}
